function Simulate_optimal_location()

% Script for simulating the dACC activity at the optimal location
% It requires to set the optimal location which can be found by running
% the Perform_Gradient_descent script. This optimal location is then used
% to run the RML. In the simulations, the optimization is run over 5
% different variables, of which the used optimal values can be found in the
% supplementary materials. 

% The script starts by changing to the relevant folder, and adding the
% folders containing the necessary scripts to the path.

cd('DA_scripts')
addpath('Functions')
addpath(pwd)

% Next, the optimal location is set. This location is a parameter
% consisting of five different entries that were optimized during the
% Gradient descent procedure. The first entry is the value of the 
% Dual_cong parameter, the parameter determining the congruency effect.
% The second entry is the parameter determining the interface between the
% boost value and the beta value. The third entry is the parameter
% determining the strength of the gaussian noise in Equation S14a and S14b.
% The fourth entry is the parameter for the characteristic decay rate, and
% the fifth entry is the conversion parameter between the DAN-generated
% reaction time and the reward penalty incurred by the RML.

location = [0.01748,0.7271,0.2836,0.4082,99.6];


% We set the number of participants to simulate during the simulation.
nparts = 200; 
substart = 1;
arg = param_build;

RT = [];
dat = [];
try
    arg.nsubj = nparts;
end

seed=round(rand(1,arg.nsubj)*1000);

% Set some of the parameters for the dual attractor, that could potentially
% be interesting to optimize over. In the simulations for the paper, only
% the congruency parameter, information parameter, standard deviation of
% the gaussian noise, kappa parameter and interface parameter between the
% reaction time generated by the DAN and the reward penalty.
arg.rt_timeout = 189; % The time limit for the dual attractor
optimization_pars.dualattractor.bias = 0; % The non-response time of the system
optimization_pars.rwupperlimit = 0; % From what time the system starts deducting reward. 
                                      % Setting this equal to the non-response time allows 
                                      % the system to start deducting reward for each time 
                                      % unit the non-resposne time is passed. 
optimization_pars.dualattractor.threshold_parameter = 3; % The treshold of the dual attractor. This value was not optimized over during the gradient descent
optimization_pars.dualattractor.congruency_parameter = location(1); % Parameter determining the congruency effect (the variable Dual_cong in Equations S16a and S16b)
optimization_pars.dualattractor.information_parameter = location(2); % Parameter determining the interface between the boost value and the beta value (see Equation S15)
optimization_pars.dualattractor.randstd = location(3); % Parameter determining the strength of the gaussian noise in Equation S14a and S14b.
optimization_pars.dualattractor.kappa= location(4); %Parameter determining the characteristic decay rate in Equation S14a and S14b.
optimization_pars.rwmult = 1/location(5); % Parameter determining the scaling between the DAN reaction time units and the reward penalty in Equation S17
n_training_trials = 10; % Number of times each state-boost pair is visited during the training

for sub=substart:arg.nsubj
    % For each subject, we first perform the DAN training
    [W,We] = Run_training_DAN(n_training_trials,arg,seed(sub),optimization_pars,0);
    dat{sub} = kenntask_vass_dual_attractor(sub,arg,seed(sub),optimization_pars,1,W,We); % Run the RML model
end

rmpath('Functions')
rmpath(pwd)
cd('..')

end